// Code generated by protoc-gen-go. DO NOT EDIT.
// source: crypto.proto

package protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KeyDerived struct {
	RootFingerprint      []byte   `protobuf:"bytes,1,opt,name=rootFingerprint,proto3" json:"rootFingerprint,omitempty"`
	Index                []byte   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	Chaincode            []byte   `protobuf:"bytes,3,opt,name=chaincode,proto3" json:"chaincode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyDerived) Reset()         { *m = KeyDerived{} }
func (m *KeyDerived) String() string { return proto.CompactTextString(m) }
func (*KeyDerived) ProtoMessage()    {}
func (*KeyDerived) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{0}
}

func (m *KeyDerived) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyDerived.Unmarshal(m, b)
}
func (m *KeyDerived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyDerived.Marshal(b, m, deterministic)
}
func (m *KeyDerived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyDerived.Merge(m, src)
}
func (m *KeyDerived) XXX_Size() int {
	return xxx_messageInfo_KeyDerived.Size(m)
}
func (m *KeyDerived) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyDerived.DiscardUnknown(m)
}

var xxx_messageInfo_KeyDerived proto.InternalMessageInfo

func (m *KeyDerived) GetRootFingerprint() []byte {
	if m != nil {
		return m.RootFingerprint
	}
	return nil
}

func (m *KeyDerived) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *KeyDerived) GetChaincode() []byte {
	if m != nil {
		return m.Chaincode
	}
	return nil
}

type PrivateKey struct {
	Version int32       `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Kd      *KeyDerived `protobuf:"bytes,7,opt,name=kd,proto3" json:"kd,omitempty"`
	// Types that are valid to be assigned to Priv:
	//	*PrivateKey_Ec
	Priv                 isPrivateKey_Priv `protobuf_oneof:"priv"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PrivateKey) Reset()         { *m = PrivateKey{} }
func (m *PrivateKey) String() string { return proto.CompactTextString(m) }
func (*PrivateKey) ProtoMessage()    {}
func (*PrivateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{1}
}

func (m *PrivateKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrivateKey.Unmarshal(m, b)
}
func (m *PrivateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrivateKey.Marshal(b, m, deterministic)
}
func (m *PrivateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateKey.Merge(m, src)
}
func (m *PrivateKey) XXX_Size() int {
	return xxx_messageInfo_PrivateKey.Size(m)
}
func (m *PrivateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateKey.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateKey proto.InternalMessageInfo

func (m *PrivateKey) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PrivateKey) GetKd() *KeyDerived {
	if m != nil {
		return m.Kd
	}
	return nil
}

type isPrivateKey_Priv interface {
	isPrivateKey_Priv()
}

type PrivateKey_Ec struct {
	Ec *PrivateKey_ECDSA `protobuf:"bytes,8,opt,name=ec,proto3,oneof"`
}

func (*PrivateKey_Ec) isPrivateKey_Priv() {}

func (m *PrivateKey) GetPriv() isPrivateKey_Priv {
	if m != nil {
		return m.Priv
	}
	return nil
}

func (m *PrivateKey) GetEc() *PrivateKey_ECDSA {
	if x, ok := m.GetPriv().(*PrivateKey_Ec); ok {
		return x.Ec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PrivateKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PrivateKey_OneofMarshaler, _PrivateKey_OneofUnmarshaler, _PrivateKey_OneofSizer, []interface{}{
		(*PrivateKey_Ec)(nil),
	}
}

func _PrivateKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PrivateKey)
	// priv
	switch x := m.Priv.(type) {
	case *PrivateKey_Ec:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PrivateKey.Priv has unexpected type %T", x)
	}
	return nil
}

func _PrivateKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PrivateKey)
	switch tag {
	case 8: // priv.ec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PrivateKey_ECDSA)
		err := b.DecodeMessage(msg)
		m.Priv = &PrivateKey_Ec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PrivateKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PrivateKey)
	// priv
	switch x := m.Priv.(type) {
	case *PrivateKey_Ec:
		s := proto.Size(x.Ec)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PrivateKey_ECDSA struct {
	Curvetype            int32    `protobuf:"varint,1,opt,name=curvetype,proto3" json:"curvetype,omitempty"`
	D                    []byte   `protobuf:"bytes,2,opt,name=d,proto3" json:"d,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrivateKey_ECDSA) Reset()         { *m = PrivateKey_ECDSA{} }
func (m *PrivateKey_ECDSA) String() string { return proto.CompactTextString(m) }
func (*PrivateKey_ECDSA) ProtoMessage()    {}
func (*PrivateKey_ECDSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{1, 0}
}

func (m *PrivateKey_ECDSA) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrivateKey_ECDSA.Unmarshal(m, b)
}
func (m *PrivateKey_ECDSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrivateKey_ECDSA.Marshal(b, m, deterministic)
}
func (m *PrivateKey_ECDSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateKey_ECDSA.Merge(m, src)
}
func (m *PrivateKey_ECDSA) XXX_Size() int {
	return xxx_messageInfo_PrivateKey_ECDSA.Size(m)
}
func (m *PrivateKey_ECDSA) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateKey_ECDSA.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateKey_ECDSA proto.InternalMessageInfo

func (m *PrivateKey_ECDSA) GetCurvetype() int32 {
	if m != nil {
		return m.Curvetype
	}
	return 0
}

func (m *PrivateKey_ECDSA) GetD() []byte {
	if m != nil {
		return m.D
	}
	return nil
}

type PublicKey struct {
	Version int32       `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Kd      *KeyDerived `protobuf:"bytes,7,opt,name=kd,proto3" json:"kd,omitempty"`
	// Types that are valid to be assigned to Pub:
	//	*PublicKey_Ec
	Pub                  isPublicKey_Pub `protobuf_oneof:"pub"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{2}
}

func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublicKey.Unmarshal(m, b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return xxx_messageInfo_PublicKey.Size(m)
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PublicKey) GetKd() *KeyDerived {
	if m != nil {
		return m.Kd
	}
	return nil
}

type isPublicKey_Pub interface {
	isPublicKey_Pub()
}

type PublicKey_Ec struct {
	Ec *PublicKey_ECDSA `protobuf:"bytes,8,opt,name=ec,proto3,oneof"`
}

func (*PublicKey_Ec) isPublicKey_Pub() {}

func (m *PublicKey) GetPub() isPublicKey_Pub {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *PublicKey) GetEc() *PublicKey_ECDSA {
	if x, ok := m.GetPub().(*PublicKey_Ec); ok {
		return x.Ec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PublicKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PublicKey_OneofMarshaler, _PublicKey_OneofUnmarshaler, _PublicKey_OneofSizer, []interface{}{
		(*PublicKey_Ec)(nil),
	}
}

func _PublicKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PublicKey)
	// pub
	switch x := m.Pub.(type) {
	case *PublicKey_Ec:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PublicKey.Pub has unexpected type %T", x)
	}
	return nil
}

func _PublicKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PublicKey)
	switch tag {
	case 8: // pub.ec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PublicKey_ECDSA)
		err := b.DecodeMessage(msg)
		m.Pub = &PublicKey_Ec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PublicKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PublicKey)
	// pub
	switch x := m.Pub.(type) {
	case *PublicKey_Ec:
		s := proto.Size(x.Ec)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PublicKey_ECDSA struct {
	Curvetype            int32    `protobuf:"varint,1,opt,name=curvetype,proto3" json:"curvetype,omitempty"`
	P                    *ECPoint `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey_ECDSA) Reset()         { *m = PublicKey_ECDSA{} }
func (m *PublicKey_ECDSA) String() string { return proto.CompactTextString(m) }
func (*PublicKey_ECDSA) ProtoMessage()    {}
func (*PublicKey_ECDSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{2, 0}
}

func (m *PublicKey_ECDSA) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublicKey_ECDSA.Unmarshal(m, b)
}
func (m *PublicKey_ECDSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublicKey_ECDSA.Marshal(b, m, deterministic)
}
func (m *PublicKey_ECDSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey_ECDSA.Merge(m, src)
}
func (m *PublicKey_ECDSA) XXX_Size() int {
	return xxx_messageInfo_PublicKey_ECDSA.Size(m)
}
func (m *PublicKey_ECDSA) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey_ECDSA.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey_ECDSA proto.InternalMessageInfo

func (m *PublicKey_ECDSA) GetCurvetype() int32 {
	if m != nil {
		return m.Curvetype
	}
	return 0
}

func (m *PublicKey_ECDSA) GetP() *ECPoint {
	if m != nil {
		return m.P
	}
	return nil
}

type Signature struct {
	// Types that are valid to be assigned to Data:
	//	*Signature_Ec
	Data                 isSignature_Data `protobuf_oneof:"data"`
	Kd                   *KeyDerived      `protobuf:"bytes,10,opt,name=kd,proto3" json:"kd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{3}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

type isSignature_Data interface {
	isSignature_Data()
}

type Signature_Ec struct {
	Ec *Signature_ECDSA `protobuf:"bytes,4,opt,name=ec,proto3,oneof"`
}

func (*Signature_Ec) isSignature_Data() {}

func (m *Signature) GetData() isSignature_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Signature) GetEc() *Signature_ECDSA {
	if x, ok := m.GetData().(*Signature_Ec); ok {
		return x.Ec
	}
	return nil
}

func (m *Signature) GetKd() *KeyDerived {
	if m != nil {
		return m.Kd
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Signature) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Signature_OneofMarshaler, _Signature_OneofUnmarshaler, _Signature_OneofSizer, []interface{}{
		(*Signature_Ec)(nil),
	}
}

func _Signature_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Signature)
	// data
	switch x := m.Data.(type) {
	case *Signature_Ec:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Signature.Data has unexpected type %T", x)
	}
	return nil
}

func _Signature_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Signature)
	switch tag {
	case 4: // data.ec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Signature_ECDSA)
		err := b.DecodeMessage(msg)
		m.Data = &Signature_Ec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Signature_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Signature)
	// data
	switch x := m.Data.(type) {
	case *Signature_Ec:
		s := proto.Size(x.Ec)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Signature_ECDSA struct {
	Curvetype int32  `protobuf:"varint,4,opt,name=curvetype,proto3" json:"curvetype,omitempty"`
	R         []byte `protobuf:"bytes,1,opt,name=r,proto3" json:"r,omitempty"`
	S         []byte `protobuf:"bytes,2,opt,name=s,proto3" json:"s,omitempty"`
	// Types that are valid to be assigned to Pub:
	//	*Signature_ECDSA_V
	//	*Signature_ECDSA_P
	Pub                  isSignature_ECDSA_Pub `protobuf_oneof:"pub"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Signature_ECDSA) Reset()         { *m = Signature_ECDSA{} }
func (m *Signature_ECDSA) String() string { return proto.CompactTextString(m) }
func (*Signature_ECDSA) ProtoMessage()    {}
func (*Signature_ECDSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{3, 0}
}

func (m *Signature_ECDSA) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature_ECDSA.Unmarshal(m, b)
}
func (m *Signature_ECDSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature_ECDSA.Marshal(b, m, deterministic)
}
func (m *Signature_ECDSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature_ECDSA.Merge(m, src)
}
func (m *Signature_ECDSA) XXX_Size() int {
	return xxx_messageInfo_Signature_ECDSA.Size(m)
}
func (m *Signature_ECDSA) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature_ECDSA.DiscardUnknown(m)
}

var xxx_messageInfo_Signature_ECDSA proto.InternalMessageInfo

func (m *Signature_ECDSA) GetCurvetype() int32 {
	if m != nil {
		return m.Curvetype
	}
	return 0
}

func (m *Signature_ECDSA) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *Signature_ECDSA) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

type isSignature_ECDSA_Pub interface {
	isSignature_ECDSA_Pub()
}

type Signature_ECDSA_V struct {
	V int32 `protobuf:"varint,3,opt,name=v,proto3,oneof"`
}

type Signature_ECDSA_P struct {
	P *ECPoint `protobuf:"bytes,5,opt,name=p,proto3,oneof"`
}

func (*Signature_ECDSA_V) isSignature_ECDSA_Pub() {}

func (*Signature_ECDSA_P) isSignature_ECDSA_Pub() {}

func (m *Signature_ECDSA) GetPub() isSignature_ECDSA_Pub {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *Signature_ECDSA) GetV() int32 {
	if x, ok := m.GetPub().(*Signature_ECDSA_V); ok {
		return x.V
	}
	return 0
}

func (m *Signature_ECDSA) GetP() *ECPoint {
	if x, ok := m.GetPub().(*Signature_ECDSA_P); ok {
		return x.P
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Signature_ECDSA) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Signature_ECDSA_OneofMarshaler, _Signature_ECDSA_OneofUnmarshaler, _Signature_ECDSA_OneofSizer, []interface{}{
		(*Signature_ECDSA_V)(nil),
		(*Signature_ECDSA_P)(nil),
	}
}

func _Signature_ECDSA_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Signature_ECDSA)
	// pub
	switch x := m.Pub.(type) {
	case *Signature_ECDSA_V:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.V))
	case *Signature_ECDSA_P:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.P); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Signature_ECDSA.Pub has unexpected type %T", x)
	}
	return nil
}

func _Signature_ECDSA_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Signature_ECDSA)
	switch tag {
	case 3: // pub.v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Pub = &Signature_ECDSA_V{int32(x)}
		return true, err
	case 5: // pub.p
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ECPoint)
		err := b.DecodeMessage(msg)
		m.Pub = &Signature_ECDSA_P{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Signature_ECDSA_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Signature_ECDSA)
	// pub
	switch x := m.Pub.(type) {
	case *Signature_ECDSA_V:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.V))
	case *Signature_ECDSA_P:
		s := proto.Size(x.P)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ECPoint struct {
	X                    []byte   `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    []byte   `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ECPoint) Reset()         { *m = ECPoint{} }
func (m *ECPoint) String() string { return proto.CompactTextString(m) }
func (*ECPoint) ProtoMessage()    {}
func (*ECPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_527278fb02d03321, []int{4}
}

func (m *ECPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ECPoint.Unmarshal(m, b)
}
func (m *ECPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ECPoint.Marshal(b, m, deterministic)
}
func (m *ECPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECPoint.Merge(m, src)
}
func (m *ECPoint) XXX_Size() int {
	return xxx_messageInfo_ECPoint.Size(m)
}
func (m *ECPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_ECPoint.DiscardUnknown(m)
}

var xxx_messageInfo_ECPoint proto.InternalMessageInfo

func (m *ECPoint) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *ECPoint) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func init() {
	proto.RegisterType((*KeyDerived)(nil), "protos.KeyDerived")
	proto.RegisterType((*PrivateKey)(nil), "protos.PrivateKey")
	proto.RegisterType((*PrivateKey_ECDSA)(nil), "protos.PrivateKey.ECDSA")
	proto.RegisterType((*PublicKey)(nil), "protos.PublicKey")
	proto.RegisterType((*PublicKey_ECDSA)(nil), "protos.PublicKey.ECDSA")
	proto.RegisterType((*Signature)(nil), "protos.Signature")
	proto.RegisterType((*Signature_ECDSA)(nil), "protos.Signature.ECDSA")
	proto.RegisterType((*ECPoint)(nil), "protos.ECPoint")
}

func init() { proto.RegisterFile("crypto.proto", fileDescriptor_527278fb02d03321) }

var fileDescriptor_527278fb02d03321 = []byte{
	// 401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0x5f, 0x6a, 0xdb, 0x40,
	0x10, 0xc6, 0xb3, 0x8a, 0x15, 0xd7, 0x13, 0xd3, 0xc0, 0x52, 0xa8, 0x08, 0xfd, 0x63, 0x04, 0x05,
	0xb7, 0x0f, 0x2a, 0x24, 0x27, 0xa8, 0xe3, 0x94, 0x40, 0x5e, 0x8c, 0xf2, 0xd6, 0x37, 0x49, 0x3b,
	0x28, 0xdb, 0x04, 0xed, 0x32, 0x5a, 0x09, 0xef, 0xb9, 0x7a, 0x82, 0x1e, 0xa4, 0x77, 0x29, 0x5a,
	0x69, 0x2d, 0xbb, 0x98, 0x52, 0xe8, 0x93, 0xf9, 0x66, 0x86, 0xf9, 0x7e, 0xdf, 0x7a, 0x04, 0xf3,
	0x82, 0xac, 0x36, 0x2a, 0xd1, 0xa4, 0x8c, 0xe2, 0x67, 0xee, 0xa7, 0x8e, 0xbf, 0x03, 0xdc, 0xa3,
	0x5d, 0x23, 0xc9, 0x16, 0x05, 0x5f, 0xc2, 0x05, 0x29, 0x65, 0xbe, 0xca, 0xaa, 0x44, 0xd2, 0x24,
	0x2b, 0x13, 0xb1, 0x05, 0x5b, 0xce, 0xd3, 0x3f, 0xcb, 0xfc, 0x15, 0x84, 0xb2, 0x12, 0xb8, 0x8d,
	0x02, 0xd7, 0xef, 0x05, 0x7f, 0x03, 0xb3, 0xe2, 0x31, 0x93, 0x55, 0xa1, 0x04, 0x46, 0xa7, 0xae,
	0x33, 0x16, 0xe2, 0x1f, 0x0c, 0x60, 0x43, 0xb2, 0xcd, 0x0c, 0xde, 0xa3, 0xe5, 0x11, 0x4c, 0x5b,
	0xa4, 0x5a, 0xaa, 0xca, 0x99, 0x84, 0xa9, 0x97, 0x3c, 0x86, 0xe0, 0x49, 0x44, 0xd3, 0x05, 0x5b,
	0x9e, 0x5f, 0xf1, 0x1e, 0xb8, 0x4e, 0x46, 0xcc, 0x34, 0x78, 0x12, 0xfc, 0x13, 0x04, 0x58, 0x44,
	0x2f, 0xdc, 0x4c, 0xe4, 0x67, 0xc6, 0xed, 0xc9, 0xed, 0xcd, 0xfa, 0xe1, 0xcb, 0xdd, 0x49, 0x1a,
	0x60, 0x71, 0x79, 0x0d, 0xa1, 0x93, 0x8e, 0xaf, 0xa1, 0x16, 0x8d, 0xd5, 0x38, 0x98, 0x8e, 0x05,
	0x3e, 0x07, 0x26, 0x86, 0x3c, 0x4c, 0xac, 0xce, 0x60, 0xa2, 0x49, 0xb6, 0xf1, 0x4f, 0x06, 0xb3,
	0x4d, 0x93, 0x3f, 0xcb, 0xe2, 0xff, 0xa1, 0x3f, 0xee, 0x41, 0xbf, 0xde, 0x41, 0xfb, 0xe5, 0x07,
	0xcc, 0xeb, 0x7f, 0x63, 0x7e, 0x0b, 0x4c, 0x3b, 0xe6, 0xf3, 0xab, 0x0b, 0xbf, 0xf0, 0xf6, 0x66,
	0xa3, 0x64, 0x65, 0x52, 0xa6, 0x57, 0x21, 0x9c, 0xea, 0x26, 0x8f, 0x7f, 0x31, 0x98, 0x3d, 0xc8,
	0xb2, 0xca, 0x4c, 0x43, 0x38, 0x50, 0x4c, 0x0e, 0x29, 0x76, 0xed, 0x7d, 0x8a, 0x21, 0x14, 0xfc,
	0x2d, 0xd4, 0xa5, 0x3d, 0x4a, 0x3a, 0x39, 0xf2, 0xba, 0x34, 0x5c, 0x13, 0xa3, 0x4e, 0xd5, 0xfe,
	0xad, 0x6b, 0xfe, 0x12, 0x58, 0xeb, 0xee, 0x25, 0xbc, 0x3b, 0x49, 0x59, 0xcb, 0xdf, 0x77, 0xa9,
	0xc2, 0xa3, 0xa9, 0xba, 0x01, 0x9f, 0xab, 0xfb, 0x8f, 0x44, 0x66, 0xb2, 0xf8, 0x03, 0x4c, 0x87,
	0x76, 0xb7, 0x78, 0xeb, 0x6d, 0xb6, 0x9d, 0xb2, 0xde, 0xc6, 0xae, 0x16, 0xdf, 0xde, 0x3d, 0x5a,
	0x8d, 0xf4, 0x8c, 0xa2, 0x44, 0x4a, 0xb2, 0xdc, 0xdd, 0x66, 0xa2, 0xa8, 0xfc, 0xdc, 0x9b, 0xe4,
	0xfd, 0x67, 0x71, 0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xe2, 0xd0, 0x9d, 0x8b, 0x2d, 0x03, 0x00,
	0x00,
}
